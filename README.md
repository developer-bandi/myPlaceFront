# 1.프로젝트 소개

장소를 찾기 위해서 구글링, 네이버 검색을 해본경험이 있을것 입니다. 보통은 한가지 키워드를 가지고 검색을 하지만, 다양한 키워드를 가지고 장소를 찾을때가 있습니다. 가령 연인끼리 가기 좋은 카페인데, 당근케이크와 딸기 케이크가 맛있으며, 오션뷰가 있는 곳 같은 경우입니다. 이럴 경우 구글에 , 로 키워드를 나누어 검색할수도 있지만, 지도와, 검색창, 검색결과를 한 페이지에 구성하여 조금더 간편하게 정보를 확인할수 있도록 플랫폼의 형태로 웹페이지를 구성하였습니다. 장소정보는 기본적으로 유저들의 기여를 통해 구성되며, 해시태그는 사용자가 제보한 것을 검토를 통해 추가하는 방식을 사용하고 있습니다.

사이트: https://movieinfoservice.netlify.app/

# 2.기술스택

- typescript: 런타임 이전에 발생할수있는 오류를 손쉽게 잡기 위해서 사용하였습니다
- next-js: ssr이 가능한 웹페이지를 제작하기위해서 사용하였습니다
- redux: 전역 상태 관리를 위해서 사용하였습니다.
- redux-toolkit: 리덕스의 보일러플레이트 코드를 줄이기위해서 사용하였습니다.
- redux-saga: api데이터를 받아오기 위해서 사용하였습니다.
- scss: 컴파일러를 통해서 css를 조금더 편리하게 사용하기 위해 도입하였습니다.
- axios: api 데이터를 받아오기 위해서 사용하였습니다.

# 3.페이지별 소개

4개 종류의 도메인이 존재합니다.

## 공통 컴포넌트

### 헤더

- 가장 왼쪽은 로고이며, 나머지 왼쪽 부분은 네비게이션 입니다.
- 오른쪽 정보는 유저의 로그인 여부를 확인할수 있는 정보란인데, 기본적으로 세션 로그인을 구현하였기에, 새로고침시에도 정보가 유지됩니다.

## 홈

- 배너에는 현재 임의의 사진이 표시되어 있지만, 만일 실제 서비스를 한다면, 슬라이더 형태로 가게 광고 혹은 공지사항을 탑재할수도 있습니다.
- 배너 하단에는 매번 업데이트되는 해시태그의 조회수 랭킹을 카테고리 별로 볼수 있습니다.

## 장소검색

- 전체화면이 지도로 렌더링 되어있고, 그위에 검색창과 상점정보가 띄워지기에, 검색창과 상점정보를 접을수 있습니다.
- 검색은 태그 검색, 이름검색 두가지이며, 다른 검색을 사용하고자 하면 이전 정보는 삭제됩니다.
- 기준장소를 설정하기 위해서 주소를 입력하거나 혹은 지도를 클릭할수 있습니다.
- 검색 이후 다시 기준장소를 설정해 검색하려면 오른쪽 하단의 검색활성화를 눌러야합니다.
- 태그 검색 과 이름검색의 결과는 동일한 ui로 구성되어 있으며, 검색결과를 클릭하게 되면 상점의 정보가 나타납니다.
- 장소 정보 탭에서는 장소 정보뿐만 아니라 로그인되어 있을경우 장소 수정, 후기 추가, 북마크 추가 등을 할수 있습니다.

## 커뮤니티

### 리스트

- 커뮤니티 리스트 위의 정렬 기준을 통해 정렬할수 있으며, 10개까지 페이지네이션 됩니다.
- 키워드를 넣고 검색하면, 제목과 내용에서 해당 키워드가 있을경우 검색결과로 출력됩니다. 이때 검색결과를 대상으로 다시 정렬을 수행할수도 있습니다.

### 디테일

- 글의 상세 정보를 표시합니다.
- 사진은 원본크기로 표시되며, 자신의 쓴 포스트 혹은 댓글의 경우 삭제할수 있습니다.

### 글쓰기

- 포스트 작성은 제목, 사진(선택), 내용 입니다.
- 사진의 경우 5kb까지 사진 파일만 가능합니다.

## 기여하기

### 후기

- 입력값을 채워서 후기를 등록할수 있습니다.
- 업데이트를 하기 위해서는 유저 정보를 통해 접근해야합니다.
- 유저 정보에서 삭제가 가능합니다.

### 상점정보

- 상점 위치정보와 세부정보를 입력하는 페이지가 나누어져 있습니다.
- 먼저 위치 정보를 입력한뒤, 세부정보를 입력해야합니다.
- 업데이트또한 위치정보와 세부정보의 업데이트 페이지가 다릅니다.

## 마이페이지

### 북마크

- 자신이 추가한 북마크 리스트가 표시됩니다.
- 북마크를 클릭하면 자동으로 이름을 기반으로 검색한 결과 페이지로 이동합니다.

### 내 후기

- 자신이 작성한 후기 목록을 볼수 있습니다.
- 수정 또는 삭제 할수 있습니다.

### 내 포스트

- 자신이 작성한 포스트 목록을 볼수 있습니다.
- 클릭시 자신의 포스트로 이동합니다.

### 내 댓글

- 자신이 작성한 댓글 목록을 볼수 있습니다.
- 클릭시 자신의 댓글로 이동합니다.

### 내 정보

- 내 정보를 가져와 렌더링합니다.
- 닉네임을 변경할수 있습니다.

### 비밀번호 변경

- 비밀번호를 변경할수 있습니다.

### 회원탈퇴

- 회원탈퇴를 진행할수 있습니다.

## 로그인/회원가입

- 로그인의 경우 소셜로그인, 로컬로그인이 가능합니다.(네이버는 저의 계정만 사용가능합니다.)
- 회원가입의 경우 로컬로그인의 경우만 진행하며, 이메일을 입력해야 인증을 할수 있습니다.
- 아이디, 비밀번호 찾기의 경우 회원가입시 입력한 이메일을 통해 인증번호를 제공하고, 이를 통해 인증하여 찾거나 재설정합니다

# 4.주요코드 정리(코드가 많아 타입스크립트는 되도록 생략하였습니다.)

# 5. 고려사항

## 1.server-side-rendering vs clientside-data-fetch

next js 는 기본적으로 빌드시 정적인 페이지를 생성합니다. 이때 빌드시에 페이지에 필요한 데이터가 정해지지 않아 사용자의 매 요청마다 새로운 데이터를 필요로 하는 경우에는 server-side-rendering(ssr)을 이용하거나, 정적인 페이지를 불러온뒤, 리액트 에서 useEffect훅을 사용해 데이터를 불러올수 있습니다. 두경우는 장단점이 있습니다. ssr의 경우 사용자가 화면을 보게 되는 시점이 아무래도 후자에 비해 느릴수 밖에 없지만, 데이터가 담긴 html이 오기때문에 seo에 강점이 있습니다. 반면 useEffect훅을 통해 데이터를 받아오는경우, 최초 사용자가 화면을 보는시점은 전자에 비해 빠르지만, 데이터가 담겨서 오지는 않기 때문에, seo측면에서는 단점이 될수 있습니다. 공식문서에서도 seo와 관련이 없는 개인정보 페이지와 같은 경우에는 클라이언트 사이드에서 데이터 fetch를 하라고 적혀있는만큼, 해당 프로젝트에서도, seo가 필요한영역에는 ssr을 그렇지 않으면 클라이언트 data fetch를 적용하였습니다. 한편 클라이언트 data fetch는 데이터가 담기지 않은 페이지가 사용자에게 먼저 보여지기 때문에, 사용자가 로딩중이라고 인식할수 있도록 ui적 처리를 하였습니다.

## 2.html 시맨틱 태그 구성

가독성 또는 seo 를 고려하기 위해서 html 를 시멘틱하게 구성하려고 노력하였습니다. 페이지 내부에 main태그를 포함시키려고 하였고, 블록을 구분할때에 논리적으로 유사한 블록 (예: 포스트 리스트) 같은 경우 제목이 있는 블록에는 section을, 제목이 없는 텍스트의 경우 ul,li의 조합을 사용하였고, 논리적으로 유사하지 않은 블록 (예: )의 경우 div를 사용하였습니다. 또한 블록 내부에서는 제목의 경우 h태그를 사용하였으며 본문을 구성할때는 p 태그를 사용하였습니다.
또한 nav등과 같은 태그들도 상황에 맞게 적절하게 구성하여, div로만 구성되지 않은 페이지를 구성하기 위해 노력하였습니다.

## 3. seo 측면 고려

앞서 언급한, ssr 과 시맨틱 태그 이외에도 그림에 alt 속성을 명확하게 기록하였으며, 페이지마다 제목과 설명 태그를 기재하였습니다.

## 4. css-in-css vs css-in-js

css 를 구성하기 위해서 프로젝트에서 채택한 방식은 css in css 입니다. 앞서 진행한 프로젝트에서 css in js 를 사용하여서 이번에는 css in css 를 사용해보고 싶은 생각이 있기도 하였고, css in js 가 이후 나온 기술이기는 하지만, 속도 측면에서 아무래도 css in js 가 느릴수 있는 측면과, 순수 css 가 전역에서 관리되어 classname을 신경써야하는 문제를 module 로 해결하수 있었기에, css in css 중의 scss 를 선택하였습니다. 비록 scss의 기능들을 많이 사용하지는 않았지만, 필요한곳에는 사용할수 있도록 노력하였습니다.

## 5. redux, redux-saga, redux-toolkit

최근 리덕스를 사용하면서, 리덕스를 구성하는 보일러플레이트 코드가 너무 많아서, 리듀서를 하나 생성하는데에도 필요이상의 코드가 들어감을 인지하게 되었습니다. 이는 리팩토링에도 영향을주고, 코드를 작성하는 동안에도, 불필요한 로직이 추가된다는 생각을 지울수가 없었습니다. 또한 사가 함수도 한 파일내에 저장하다보니 가독성에 있어서도 문제가 발생하였습니다. 이러한 문제를 해결하기위해서 redux-toolkit을 사용하여 보일러플레이트 코드를 많이 줄이게 되었고, 사가는 아예 다른 파일로 분리하고 리듀서와 사가를 한 폴더로 묶는 방식으로 작업하였더니, 가독성 측면에서 확실히 좋아지게 되었고, 코드를 작성하거나 개선할때에도 조금더 쉽게 읽히게 되어서, 앞으로 리덕스를 계속해서 사용한다면 redux-toolkit을 반드시 사용해야겠다는 생각을 가지게 되었습니다.

## 6. 상황별 ui 구성으로 ux 향상

데이터를 받아오지 않고 정적인 html 만 렌더링 하는 페이지의 경우, html 페이지를 받아오지 못하는 경우가 아니라면, 다양한 상황이 발생하지는 않습니다. 그러나 데이터를 받아오는 경우, 여러가지 측면에서 문제가 발생할수 있고, 따라서 서버에서 에러가 발생할경우, 에러 처리를 통해 사용자에게 에러가 발생함을 alert 혹은 페이지내 텍스트로 표기하였습니다. 또한 클라이언트에서 데이터를 받아오는 경우에는 반드시 로딩처리를 하여, 해당 작업이 진행중임을 사용자에게 알려주었습니다.

## 7. 반응형

반응형 디자인은 모바일, 태블릿, 랩탑(일부분), 데스크탑을 기준으로 하였습니다. 대부분의 디자인은 데스크탑의 크기가 모바일에 맞게 줄어들기만 한 형태이지만 헤더의 경우 모바일에서는 길이가 짧아 2단 구성을 하였고 마이페이지의 경우 상단 헤더에서 목록을 호출하고, 페이지 내에서의 네비게이션은 없애는 방식을 적용하였습니다. 또한 장소찾기 페이지에서는 지도와 찾는 부분을 상하단으로 나누고, 장소 페이지는 검색결과 위에 덮는 식으로 적용하였습니다.

# 6. 버전 개선 기록

## 1.0.0

- 파일을 처음 빌드 하였습니다.
