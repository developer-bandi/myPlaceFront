# MyPlace

<p>사용기술 : next-js, redux,redux-toolkit, redux-saga, scss,typescript, jest, testing-library</p>
<p style="margin:0 0 20px 0;">웹사이트 : <a href="https://movieinfoservice.netlify.app/">https://my-place-front-eosin.vercel.app</a></p>
<p>(네이버 소셜 로그인은 관리자만 사용가능하며 서버가 sleep 상태 이므로 30초정도를 기다려야합니다)</p>

## 1.프로젝트 소개

장소를 찾기 위해서 구글링, 네이버 검색을 해본경험이 있을것 입니다. 보통은 한가지 키워드를 가지고 검색을 하지만, 다양한 키워드를 가지고 장소를 찾을때가 있습니다. 가령 연인끼리 가기 좋은 카페인데, 당근케이크와 딸기 케이크가 맛있으며, 오션뷰가 있는 곳 같은 경우입니다. 이런 공간을 쉽게 찾을수 있도록 키워드 기반의 장소 검색을 서비스 하는 프로젝트입니다

## 2.주요 기능 소개

### 로그인

유저 로그인은 네이버/카카오 소셜로그인과 로컬로그인 두가지중 한가지로 수행할수 있습니다.

로컬로그인의 경우 아이디를 찾거나 비밀번호를 재설정 할수있는데, 이는 회원가입시 입력한 이메일에 전달된 난수번호를 입력함으로써 수행할수 있습니다.

### 장소 검색

장소검색은 태그 검색과 키워드 검색 두가지가 가능합니다. 태그 검색의 경우, 태그를 선택하여 검색하며, 키워드 검색은 장소이름을 직접 입력하여 검색하게 됩니다.

검색절차는, 기준위치를 결정한후, 태그 혹은 키워드를 입력하고 검색을 누르면, 기준위치에서 가까운 순서대로 장소가 결과창에 나오게됩니다.

그중 관심있는 장소를 누르게되면 장소에 대하여 주소, 영업시간 전화번호 메뉴판 후기 등 더 자세한 정보를 볼수 있으며, 경우에따라 후기를 남기거나, 해당정보를 수정해 기여하거나, 해당장소를 북마크 할수 있습니다

### 장소 등록/수정하기

기여하기 탭을 통해 장소를 등록하거나 혹은 장소검색을 통해 볼수있는 장소 세부탭에서 장소에 대한 정보를 수정할수 있습니다.

후기의 경우는 기여하기 탭을 통하여 진입할수는있으나, 장소 검색을 통해서만 등록할수있고 후기를 수정하기 위해서는 개인 페이지에서 수정할수 있습니다.

### 커뮤니티

커뮤니티 리스트에서는 포스트를 정렬 조건에 맞추어 정렬할수 있고, 키워드를 입력하여 검색할수 있습니다. 검색후에도, 정렬을 사용하면 검색된 값을 기준으로 정렬합니다.

커뮤니티 리스트에서 글을 하나 클릭하여 상세 페이지로 들어가게 되면, 댓글을 달거나 좋아요를 표시할수 있습니다. 좋아요를 표시하게되면 작성자에게, 댓글을 달면 작성자와 댓글 작성자에게 알림이 가게 됩니다.

커뮤니티 리스트를 통해 글을 작성할수도 있습니다. 글쓰기 버튼을 통해서 이동할수 있으며, 글, 제목 간단한 사진을 업로드 할수 있도록 되어있습니다.

### 마이페이지

북마크,자신이 작성한 후기,포스트,댓글 을 볼수 있으며 개인정보를 수정하거나 회원탈퇴를 진행할수 있습니다.

## 3. 사용 기술 상세

### 폴더 구조

컴포넌트의 폴더구조는 도메인을 기준으로 나누었습니다. 한 컴포넌트 내에는 훅, 프레젠테이션,컨테이너, 테스트,스타일 총5개가 기본적으로 포함되며 경우에따라 스타일이 공통스타일로 관리되면 없을수 있고, 비즈니스 로직이 없다면 훅가 컨테이너가 없을수있습니다.

훅에는 해당 프레젠테이션에서 사용되는 비즈니스 로직이 들어가며 컨테이너에서는 훅의 로직뿐만 아니라 커스텀 훅의 로직을 받는 공간입니다.

사실 많은 컴포넌트에서 커스텀훅을 받지않고, 훅 한개만을 받아 사용하는데, 이럴경우 컨테이너는 단순히 전달하는 역할이라서, 프레젠테이션에서 훅을 바로 사용해도 문제가 없을수 있습니다. 하지만 저는 props로 받아 타입을 선언하는것이 컴포넌트에대한 설명을 해줄수 있다고 생각하였기에, 이러한 폴더구조를 유지하였습니다.

### ssg / isr / ssr / csr

next js 에서는 ssg, isr ssr 순서로 채택하도록 권하고있기에, 이를 반영하여 기준을 구성하였습니다.

- ssg : 빌드이후 변화가 생기지 않는 경우 선택하는데, 해시태그의 목록같은경우가 이에 해당한다.
- isr: 빌드이후 자주 변화가 생가지 않는 경우 선택하는데, 홈의 배너와, 장소 순위목록이 이에 해당한다. 변경되는 시간을 명시해 줌으로써 유저에게 변화가 진행중이라는 느낌을 줄수도 있다.
- ssr: 빌드이후 자주 수정되면서 seo가 필요한 영역에 적용한다. 예를 들면 포스트 정보가 이에 해당한다
- csr: 빌드이후 자주 수정되지만 seo가 필요없는 영역에 적용한다. nextjs 공식홈페이지에서도 권장하듯이 마이페이지같은경우가 대표적으로 이에 해당하고, 이외에 장소 정보를 찾는 페이지도 seo가 무조건 필요하다고 생각하지는 않아서 csr로 렌더링 하였다.

### 상태관리(redux,redux-saga)

상태관리는 생태계가 크고 여전히 많이 사용되고 있는 redux와 redux-saga를 사용하였습니다. 최근에는 redux-saga대신 api를 react-query로 관리하는 경우가 늘고 있지만, 해당 프로젝트에서 캐싱이 필요한 api가 많지 않고, api를 호출하는 보일러플레이트를 커스텀 훅으로 관리하여 어느정도 단점을 잡았다고 생각하고 개인적으로 redux-saga의 구조에 불편함이 없기에 사용하였습니다.

redux와 함께 redux-toolkit을 사용하였습니다. 기능적인 이점이 있지는 않지만 redux의 단점인 보일러플레이트 코드를 많이 줄여주기 때문입니다.

redux-saga로 불러오는 정보는 캐싱이 필요한 정보에 한해서 사용하였습니다. 이외의 api는 호출이 필요한 컴포넌트에서 호출하였습니다. 또한 이후 유지보수에 지장이 있을것 같아 redux의 한개의 리듀서에 너무많은 정보를 포함하지 않도록 노력하였습니다.

### 반응형(react-responsive,scss)

구조가 변경되어야 하는경우 react-responsive라이브러리를 사용하여, 화면의 크기에 따라 컴포넌트가 어떻게 구성되는지를 결정하였고, 단순히 비율을 조정하는 정도라면 css를 활용하였습니다. 이과정에서 가장 요긴하게 사용된 것은 vh,vw와같이 뷰포트를 기준으로 결정되는 단위와 다양한 단위들을 혼합하여 계산할수 있게 해주는 calc이라는 함수였습니다. 이러한 함수를 이용하여 뷰포트의 높이가 높아서 footer이하가 잘려 다소 좋지 않은 모습을 보여주는 경우에, footer가 맨 하단에 붙도록 할수 있었습니다.

또한 북마크의 경우, 4개이상이 존재할경우, 사이즈에 따라 3,2 개로 줄어드는데, 이과정에서 이미지 사이즈를 유지하면서 커졌다가 작아지는 과정을 반복하는데, 이또한 반응형을 고려하였습니다.

### 테스트(jest,react-testinglibrary)

테스트는 크게 프레젠테이션컴포넌트와, 훅, 그리고 리덕스와 사가 코드로 나눌수 있습니다. 프레젠테이션 코드는 storybook을 이용해서 시각적으로 테스트하였고, 훅은 useEffect가 있다면 해당 테스트와, 함수의 작동이 잘 되는지를 체크하였습니다. 리덕스의 경우 리듀서함수가 잘 작동하는지를 체크하였고, 사가의 경우에도 saga-test-plain라이브러리를 이용하여, 가짜로 액션을 발생시킨뒤에 해당 사가가 발생하는지를 테스트 하였습니다.

카카오 맵의 경우 함수가 복잡하여 mocking하는데 어려움이 많았던것 같습니다. 이러한 이유때문에 너무 복잡한 mocking 이필요한경우 테스트를 하지 못했습니다.

### 성능 체크 (lighthouse)

lighthouse를 이용하여 성능 테스트를 간단하게 진행하였습니다. 대부분의 페이지에 적용하였고, 간단한 수정으로 점수가 많이 상승하였습니다.

- image/next 태그를 통해 화면에 보이지 않은 요소는 미리 렌더링하지 않고, 가능한경우, 웹 친화적인 확장자로 변경해주는 점을 이용하고, 서버로부터 이미지를 작게 가져오는 방법을 사용하여 이미지 최적화하였음 . 대부분의 지표가 긍정적으로 변경(home page)
- document 페이지를 이용하여 언어설정
- aria label을 이용하여 버튼 혹은 인풋에 관련 정보가 없을경우 대체 정보를 삽입
- h태그가 순차적으로 구성되어있지 않은경우, 이를 순차적으로 구성

### 배포 및 이슈관리

프론트 배포는 vercel로 하였으며 깃허브와 연동하여 자동으로 배포가 될수 있도록 구성하였습니다. 또한 배포 이후에는 문제가 발생하면 이슈를 등록하고 이슈 단위로 커밋을 진행하였습니다.

### 타입 스크립트

redux와 타입스크립트를 사용하였을때, useSelector로 스토어의 값을 가져오고자 할때, 오타를 발생시키는 실수를 하지 않는것 처럼, api등의 객체 프로퍼티를 사용할때, 실수를 할 가능성이 굉장히 줄어들고, 자동완성이 쉽기 때문에, 시간도 단축된다고 생각합니다.

또한 리액트 컴포넌트에서 props를 받아오는데, 사실 이름만가지고 이것이 어떠한 역할을 하는지 알기 쉽지 않습니다. 리액트에서 지원하는 propsTypes 처럼 props들이 대략적으로 어떤 기능을 갖는지 알수 있는 문서 역할을 할수 있다고 생각합니다.

## 4.트러블 슈팅 & 경험 사항

아래 제목을 누르면 관련 블로그글을 확인할수 있습니다.

### [좋아요 기능 개선](!https://velog.io/@dujk68/%EC%82%AC%EC%9A%A9%EC%9E%90-%EA%B2%BD%ED%97%98%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0-%EC%A2%8B%EC%95%84%EC%9A%94-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)

처음 좋아요 기능을 구현할때는 일반적은 api 처리 흐름 처럼 유저가 좋아요 버튼을 누르면 api 요청을 보내고 응답을 받으면 그결과를 화면에 적용하는 방식으로 처리하였습니다. 하지만, 이렇게 하니 유저가 클릭한뒤 반영되는데 1초이상이 걸렸고, 좋아요 기능은 일반적으로 즉각적으로 반영되어야 사용자 경험에 좋은것 같아 일단 화면에 결과를 반영한뒤, api 요청결과 에러일경우 다시 원래대로 돌리고, 그렇지 않은경우 유지하는 식으로 하였습니다.

이렇게 고민을 하고나니, 유저가 여러번 좋아요 버튼을 누를 경우에대해서도 고민하게 되었습니다. 구현한 코드대로라면 유저가 버튼을 누르는만큼 api 요청을 보내게 되는데, 유저가 실수나 의도적으로 연속해서 여러번 누르는 경우, 굳이 요청을 다보내지 않고 마지막 결과만 보내더라도 아무문제가 없다고 생각하여 debounce를 적용하여 일정시간이내에 요청이 없을때, 해당 요청을 보내도록하여 요청횟수를 줄였고, 여기서 조금더 개선하여 만약 사용자가 좋아요버튼을 짝수번 눌러서 초기상태와 동일할경우, 화면에는 계속해서 변경되지만, 결과적으로 변한것은 없으므로 요청을 보내지 않도록 하여 조금더 개선하였습니다.

### [image 사이즈 조정](https://velog.io/@dujk68/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0)

홈 화면일때 브라우저의 다른 탭을 갔다가오면 1초정도 화면이 모두 하얗게 변하는 현상이 있었습니다. 다행히 이는 브라우저의 탭을 너무많이 켜두어서 생기는 문제여서 브라우저를 다시 시작하면서 해결하였습니다. 하지만, 다른 사이트의경우 탭을 많이 열어둔다고해서 해당문제가 발생하지 않으므로 탭이 많이 열려있어도 하얗게 변하지 않도록 하기위해 문제를 해결하고자 하였습니다.

다른페이지에서는 해당 문제가 발생하지않았기에, 차이점을 고민해보니, 사진갯수의 차이였습니다. 그리고 lighthouse로 체크해보니 사진 용량을 99퍼센트정도 줄여도 정상적으로 렌더링이 가능하다고 하여서 받아오는 이미지를 렌더링하는 사이즈의 대략 2배정도의 크기로 줄여서 위 문제를 해결함과 동시에 초기 이미지 렌더링 시간도 크게 줄일수 있었습니다.

### [ssg, ssr, isg 적절하게 적용하기](https://velog.io/@dujk68/next-js%EB%A1%9C-pre-render-%ED%95%98%EA%B8%B0)

제가 만든 서비스는 실제 운영을 위해서 만든것은 아니지만, seo 측면에서 이점이 있으면 좋을것 같아 pre-fetch가 가능한 함수들을 적절하게 사용하였습니다. seo 측면을 고려하지않아도 되는 마이페이지 등에서는 기존에 react 에서 사용하는 data-fetch 를 사용하였고, seo를 고려해야하는 페이지이더라도, 만약 데이터가 항상 최신이지 않아도 된다면, isr을 고려하여 가능한 html을 미리 생성해두고 받아올수있도록해서 렌더링 성능을 고려하였습니다.

위 경우들을 고려하더라도 ssr을 사용해야한다면, 사용하되, 사용자 경험을 고려하였습니다. ssr을 적용한페이지는 api 요청 응답 시간에따라 다르지만 1~3초 정도의 대기시간이 발생합니다. 이는 서버에서 요청응답을 처리하고 페이지를 만들어 내려보내기때문입니다. 그동안에 다른 처리를 하지 않는다면 사용자는 페이지 전환시 기존페이지를 계속 보게 되므로 마치 렉이 걸린것 같아보입니다. 이를 해결하기 위해서 ssr을 적용하는 페이지에는 간단한 로딩을 적용하여 사용자에게 페이지가 로딩되고 있음을 알려주도록 하였습니다.

### [컴포넌트 분리하기](https://velog.io/@dujk68/react-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%B6%84%EB%A6%AC%ED%95%98%EA%B8%B0)

처음 redux를 배웠을때, 프리젠테이션 컨테이너 형식을 사용하여 컴포넌트를 분리하였습니다. 프리젠테이션 컴포넌트에는 ui로직을 담고, 컨테이너 로직에는 비즈니스로직, 즉 redux를 사용하는 로직을 담았습니다. 실제 비즈니스 로직은 redux코드에 담겨있게 되었습니다. 하지만 이후 custom hook를 사용하면서, 프리젠테이션 컴포넌트에서 ui 를 독립적으로 유지하는것은 좋다고 생각했으나, hook를 자주사용하다보니 굳이 컨테이너 컴포넌트가 필수라는 생각이 들지 않았고 이때문에 대부분 hook을 프리젠테이션 컴포넌트에서 불러오는 방식을 사용하였고, 컨테이너 컴포넌트는 거의 사용하지 않게되었습니다.

이러한 상황에서 스토리북을 이용하여 ui 테스트를 하게 되었습니다. 그런데 ui컴포넌트를 직접 불러오다보니, hook을 내부에서 불러와 사용하는경우 의존성을 가지게 되어 테스트할때 해당 의존성을 구체적으로 삽입해주어야하는경우가 발생하였습니다. 이를 계기로 다시 컨테이너 컴포넌트를 hook과 ui의 매개로 사용하여 ui는 인자로 받은 요소를 화면에 보여주는 역할만 하고, 이를 불러오는것은 컨테이너 컴포넌트에서 함으로써 ui 테스트를 좀더 수월하게 할수 있었습니다.

### [무한 스크롤 구현하기](https://velog.io/@dujk68/react%EC%99%80-%ED%95%A8%EA%BB%98-Infinity-scroll-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)

홈화면의 리뷰는 현재 41개 밖에 되지 않아서, 처음에는 모든 요소를 다 불러와서 화면에 렌더링하는 형태였습니다. 하지만 이후 리뷰가 늘어나게될 경우 불러올때나 이를 렌더링할때 성능저하가 크게 발생할것 같아 확장가능성을 고려하여 무한스크롤을 적용하게 되었습니다.

나와있는 라이브러리를 사용할수도 있었으나 무한 스크롤의 핵심기술을 학습하고자 하는 취지에서 직접 구현해보았습니다. 단순히 스크롤 이벤트나 intersection observer등을 이용해 무한스크롤을 구현하는것은 어렵지 않았습니다. 하지만 실제 화면에 보이는 요소만 렌더링하는 가상화를 적용하는 부분에 고려할 부분이 많아서 어려웠습니다.

특히 고민을 많이했던 부분은 마지막을 감지하는 방법이었습니다. 저는 마지막 요소가 보이는 순간에 다음 페이지를 로드할수 있도록 하는것이 좋다고 생각하였는데, 제가 만든 무한스크롤이 처음 요소갯수가 작아서 스크롤이 마지막에서 두번째 요소까지밖에 내려가지 않아 감지할수가 없었습니다. 이를 계산하여 예외처리 할수도 있었지만, 조금더 간단하게 할수있는 방법을 고민했고, 이에 떠올린 방식이 페이지 마지막을 감지할수있는 요소를 두는것이었습니다. 모든 요소의 높이의 합만큼의 높이를 가지는 가상요소의 맨마지막에 요소높이만큼의 마지막 체크용 요소를 두고 intersection observer를 이용하여 요소가 보일때 데이터를 요청하고, 위치는 매번 바닥에 붙여놓으므로 컨텐츠가 로드되면 다시 맨 아래로 내려가도록 처리하여 구현할수 있었습니다.

### [무한 캐러셀 구현하기](https://velog.io/@dujk68/%EB%AC%B4%ED%95%9C-%EC%BA%90%EB%9F%AC%EC%85%80-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0with-react)

처음 캐러셀을 구현할때는 슬라이드 효과가 없고 단순히 화면이 변경되는 방식이었습니다. 하지만 대부분의 웹사이트에서 배너에 이동하는 효과를 포함하고있고 이것이 ui측면에서 충분히 장점을 가질수 있다고 생각하여 이후에 개선하였습니다.

이 부분도 위와 마찬가지로 나와있는 라이브러리를 사용하기보다 핵심기술을 학습하기 위해서 직접 구현하였습니다. 검색해본결과 구현하는 방식은 리스트를 모두 렌더링하고, 마지막과 처음 요소를 각각 반대편에 하나씩 두어서 마지막, 처음요소에 도달할경우 원래 위치로 돌려주는 방식이었습니다. 구현하고 나니 잘 동작하였는데, 여기에는 한가지 문제가 있었습니다. 애니메이션 효과가 끝나기 이전에 사용자가 다시 버튼을 누르는경우 끊기는 현상이 나타났습니다. 이는 구현할때 애니메이션이 완료되는 시점에 처음으로 돌아가도록 해두었기 때문입니다. 따라서 이를 개선하려면 간단하게는 애니메이션이 완료되기 전에 이동을 막는 방법이 있었는데, 이동을 막는것도 좋지만, 실제 이동을 계속 하게 해달라는 요구사항이 있을수 있으므로 처음 일반적인 방식으로 구현한 무한 캐러셀을 좀더 발전시켜 보았습니다.

간단한 아이디어인데, 요소가 애니메이션 효과를 진행중일때, 이동하려고 하면, 애니메이션 효과를 종료하고 바로 해당화면으로 넘어가게 하는것입니다. 그런데, 이를 애니메이션 지연 시간이 1s정도에서 시도하면 굉장히 끊기는 느낌이 나므로 대략 0.2~0.3초 정도의 시간을 설정하여 구현해보면 나쁘지 않은 ui를 경험할수 있습니다. 또한 앞서 구현한 방식에서 모든 리스크를 렌더링하지 않고, 실제 한개만 렌더링하고 있다가 왼쪽을 누르면 왼쪽 요소를, 오른쪽을 누르면 오른쪽요소를 렌더링하는 방식으로 이동중에는 2개, 그렇지 않을경우 1개만 렌더링되도록 하여 조금더 개선할수 있었습니다.
