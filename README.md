# 1.프로젝트 소개

장소를 찾기 위해서 구글링, 네이버 검색을 해본경험이 있을것 입니다. 보통은 한가지 키워드를 가지고 검색을 하지만, 다양한 키워드를 가지고 장소를 찾을때가 있습니다. 가령 연인끼리 가기 좋은 카페인데, 당근케이크와 딸기 케이크가 맛있으며, 오션뷰가 있는 곳 같은 경우입니다. 이럴 경우 구글에 , 로 키워드를 나누어 검색할수도 있지만, 지도와, 검색창, 검색결과를 한 페이지에 구성하여 조금더 간편하게 정보를 확인할수 있도록 플랫폼의 형태로 웹페이지를 구성하였습니다. 장소정보는 기본적으로 유저들의 기여를 통해 구성됩니다.

사이트: https://movieinfoservice.netlify.app/

# 2.기술스택

- typescript: 런타임 이전에 발생할수있는 오류를 손쉽게 잡기 위해서 사용하였습니다
- next-js: ssr이 가능한 웹페이지를 제작하기위해서 사용하였습니다
- redux: 전역 상태 관리를 위해서 사용하였습니다.
- redux-toolkit: 리덕스의 보일러플레이트 코드를 줄이기위해서 사용하였습니다.
- redux-saga: api데이터를 받아오기 위해서 사용하였습니다.
- scss: 컴파일러를 통해서 css를 조금더 편리하게 사용하기 위해 도입하였습니다.
- jest: 테스트를 위해 사용하였습니다.
- testing-library: 테스트를 위해 사용하였습니다.

# 3.페이지별 소개

4개 종류의 도메인이 존재합니다.

## 공통 컴포넌트

### 헤더

- 가장 왼쪽은 로고이며, 나머지 왼쪽 부분은 네비게이션 입니다.
- 오른쪽 정보는 유저의 로그인 여부를 확인할수 있는 정보란인데, 기본적으로 세션 로그인을 구현하였기에, 새로고침시에도 정보가 유지됩니다.

## 홈

- 배너는 사진이 아닌, html 로 되어있고, isr을 사용하여 빠르게 렌더링됩니다.
- 인기 장소는 업데이트주기가 24시간이며, isr을 사용하였기에 빠르게 렌더링됩니다.
- 리뷰는 최신 리뷰가 필요하여, isr을 적용시키지 않고 클라이언트 에서 매번 최신 리뷰를 렌더링 합니다.

## 장소검색

- 전체화면이 지도로 렌더링 되어있고, 그위에 검색창과 상점정보가 띄워지기에, 검색창과 상점정보를 접을수 있습니다.
- 검색은 태그 검색, 이름검색 두가지이며, 다른 검색을 사용하고자 하면 이전 정보는 삭제됩니다.
- 기준장소를 설정하기 위해서 주소를 입력하거나 혹은 지도를 클릭할수 있습니다.
- 검색 이후 다시 기준장소를 설정해 검색하려면 오른쪽 하단의 검색활성화를 눌러야합니다.
- 태그 검색 과 이름검색의 결과는 동일한 ui로 구성되어 있으며, 검색결과를 클릭하게 되면 상점의 정보가 나타납니다.
- 장소 정보 탭에서는 장소 정보뿐만 아니라 로그인되어 있을경우 장소 수정, 후기 추가, 북마크 추가 등을 할수 있습니다.

## 커뮤니티

### 리스트

- 커뮤니티 리스트 위의 정렬 기준을 통해 정렬할수 있으며, 10개까지 페이지네이션 됩니다.
- 키워드를 넣고 검색하면, 제목과 내용에서 해당 키워드가 있을경우 검색결과로 출력됩니다. 이때 검색결과를 대상으로 다시 정렬을 수행할수도 있습니다.

### 디테일

- 글의 상세 정보를 표시합니다.
- 사진은 원본크기로 표시되며, 자신의 쓴 포스트 혹은 댓글의 경우 삭제할수 있습니다.

### 글쓰기

- 포스트 작성은 제목, 사진(선택), 내용 입니다.
- 사진의 경우 5kb까지 사진 파일만 가능합니다.

## 기여하기

### 선택

- 먼저 후기를 작성할지, 상점정보를 작성할지 결정해야합니다.
- 후기를 선택할경우, 먼저 상점을 검색해야하기에, 장소검색페이지로 이동합니다.
- 장소를 선택할경우, 바로 장소등록 페이지로 이동합니다.

### 후기

- 입력값을 채워서 후기를 등록할수 있습니다.
- 업데이트를 하기 위해서는 유저 정보를 통해 접근해야합니다.
- 유저 정보에서 삭제가 가능합니다.

### 상점정보

- 상점 위치정보와 세부정보를 입력하는 페이지가 나누어져 있습니다.
- 먼저 위치 정보를 입력한뒤, 세부정보를 입력해야합니다.
- 업데이트또한 위치정보와 세부정보의 업데이트 페이지가 다릅니다.

## 마이페이지

### 북마크

- 자신이 추가한 북마크 리스트가 표시됩니다.
- 북마크를 클릭하면 자동으로 이름을 기반으로 검색한 결과 페이지로 이동합니다.

### 내 후기

- 자신이 작성한 후기 목록을 볼수 있습니다.
- 수정 또는 삭제 할수 있습니다.

### 내 포스트

- 자신이 작성한 포스트 목록을 볼수 있습니다.
- 클릭시 자신의 포스트로 이동합니다.

### 내 댓글

- 자신이 작성한 댓글 목록을 볼수 있습니다.
- 클릭시 자신의 댓글로 이동합니다.

### 내 정보

- 내 정보를 가져와 렌더링합니다.
- 닉네임을 변경할수 있습니다.
- 로컬 로그인의 경우 비밀번호를 재설정할수 있습니다.

### 회원탈퇴

- 회원탈퇴를 진행할수 있습니다.

## 로그인/회원가입

- 로그인의 경우 소셜로그인, 로컬로그인이 가능합니다.(소셜 로그인은 현재 관리자 계정만 로그인이 가능합니다)
- 회원가입의 경우 로컬로그인의 경우만 진행하며, 이메일을 입력해야 인증을 할수 있습니다.
- 아이디, 비밀번호 찾기의 경우 회원가입시 입력한 이메일을 통해 인증번호를 제공하고, 이를 통해 인증하여 찾거나 재설정합니다

# 4. 고려사항

## 1.server-side-rendering vs clientside-data-fetch

next js 는 기본적으로 빌드시 정적인 페이지를 생성합니다. 이때 빌드시에 페이지에 필요한 데이터가 정해지지 않아 사용자의 매 요청마다 새로운 데이터를 필요로 하는 경우에는 server-side-rendering(ssr)을 이용하거나, 정적인 페이지를 불러온뒤, 리액트 에서 useEffect훅을 사용해 데이터를 불러올수 있습니다. 두경우는 장단점이 있습니다. ssr의 경우 사용자가 화면을 보게 되는 시점이 아무래도 후자에 비해 느릴수 밖에 없지만, 데이터가 담긴 html이 오기때문에 seo에 강점이 있습니다. 반면 useEffect훅을 통해 데이터를 받아오는경우, 최초 사용자가 화면을 보는시점은 전자에 비해 빠르지만, 데이터가 담겨서 오지는 않기 때문에, seo측면에서는 단점이 될수 있습니다. 공식문서에서도 seo와 관련이 없는 개인정보 페이지와 같은 경우에는 클라이언트 사이드에서 데이터 fetch를 하라고 적혀있는만큼, 해당 프로젝트에서도, seo가 필요한영역에는 ssr을 그렇지 않으면 클라이언트 data fetch를 적용하였습니다. 한편 클라이언트 data fetch는 데이터가 담기지 않은 페이지가 사용자에게 먼저 보여지기 때문에, 사용자가 로딩중이라고 인식할수 있도록 ui적 처리를 하였습니다.

## 2.html 시맨틱 태그 구성

가독성 또는 seo 를 고려하기 위해서 html 를 시멘틱하게 구성하려고 노력하였습니다. 페이지 내부에 main태그를 포함시키려고 하였고, 블록을 구분할때에 논리적으로 유사한 블록 (예: 포스트 리스트) 같은 경우 제목이 있는 블록에는 section을, 제목이 없는 텍스트의 경우 ul,li의 조합을 사용하였고, 논리적으로 유사하지 않은 블록 (예: )의 경우 div를 사용하였습니다. 또한 블록 내부에서는 제목의 경우 h태그를 사용하였으며 본문을 구성할때는 p 태그를 사용하였습니다.
또한 nav등과 같은 태그들도 상황에 맞게 적절하게 구성하여, div로만 구성되지 않은 페이지를 구성하기 위해 노력하였습니다.

## 3. seo 측면 고려

앞서 언급한, ssr 과 시맨틱 태그 이외에도 그림에 alt 속성을 명확하게 기록하였으며, 페이지마다 meta 태그를 이용하여 제목과 설명 태그를 기재하였습니다.

## 4. css-in-css vs css-in-js

css 를 구성하기 위해서 프로젝트에서 채택한 방식은 css in css 입니다. 앞서 진행한 프로젝트에서 css in js 를 사용하여서 이번에는 css in css 를 사용해보고 싶은 생각이 있기도 하였고, css in js 가 이후 나온 기술이기는 하지만, 속도 측면에서 아무래도 css in js 가 느릴수 있는 측면과, 순수 css 가 전역에서 관리되어 classname을 신경써야하는 문제를 module 로 해결하수 있었기에, css in css 중의 scss 를 선택하였습니다. 비록 scss의 기능들을 많이 사용하지는 않았지만, 필요한곳에는 사용할수 있도록 노력하였습니다.

## 5. redux, redux-saga, redux-toolkit

최근 리덕스를 사용하면서, 리덕스를 구성하는 보일러플레이트 코드가 너무 많아서, 리듀서를 하나 생성하는데에도 필요이상의 코드가 들어감을 인지하게 되었습니다. 이는 리팩토링에도 영향을주고, 코드를 작성하는 동안에도, 불필요한 로직이 추가된다는 생각을 지울수가 없었습니다. 또한 사가 함수도 한 파일내에 저장하다보니 가독성에 있어서도 문제가 발생하였습니다. 이러한 문제를 해결하기위해서 redux-toolkit을 사용하여 보일러플레이트 코드를 많이 줄이게 되었고, 사가는 아예 다른 파일로 분리하고 리듀서와 사가를 한 폴더로 묶는 방식으로 작업하였더니, 가독성 측면에서 확실히 좋아지게 되었고, 코드를 작성하거나 개선할때에도 조금더 쉽게 읽히게 되어서, 앞으로 리덕스를 계속해서 사용한다면 redux-toolkit을 반드시 사용해야겠다는 생각을 가지게 되었습니다.

## 6. 상황별 ui 구성으로 ux 향상

데이터를 받아오지 않고 정적인 html 만 렌더링 하는 페이지의 경우, html 페이지를 받아오지 못하는 경우가 아니라면, 다양한 상황이 발생하지는 않습니다. 그러나 데이터를 받아오는 경우, 여러가지 측면에서 문제가 발생할수 있고, 따라서 서버에서 에러가 발생할경우, 에러 처리를 통해 사용자에게 에러가 발생함을 alert 혹은 페이지내 텍스트로 표기하였습니다. 또한 클라이언트에서 데이터를 받아오는 경우에는 반드시 로딩처리를 하여, 해당 작업이 진행중임을 사용자에게 알려주었습니다.

## 7. 반응형

반응형 디자인은 모바일, 태블릿, 랩탑(일부분), 데스크탑을 기준으로 하였습니다. 대부분의 디자인은 데스크탑의 크기가 모바일에 맞게 줄어들기만 한 형태이지만 헤더의 경우 모바일에서는 길이가 짧아 2단 구성을 하였고 마이페이지의 경우 상단 헤더에서 목록을 호출하고, 페이지 내에서의 네비게이션은 없애는 방식을 적용하였습니다. 또한 장소찾기 페이지에서는 지도와 찾는 부분을 상하단으로 나누고, 장소 페이지는 검색결과 위에 덮는 식으로 적용하였습니다.

## 8. form 데이터 전송

기본적으로 form 데이터를 전송할때에는 html form 양식에 맞게 태그를 구성한후 submit을 누르면 서버로 전송을 해주게 됩니다.

텍스트 같은 데이터는 form 데이터에 담을 필요가 없지만, 사진이 포함되는 경우 form 양식안에 담아주어야 합니다. 이번 경우는 그림이 포함되어있으면서 경우에 따라서는 form 태그 안에 들어있는 데이터만 전송해야 하지 않을때도 있어서, 이러한 상황을 해결하기 위해 데이터를 FormData 객체의 양식에 담아서 전송하였습니다.

## 9. 데이터 수정시 사진 관련 내용

리뷰와 스토어의 경우 사진을 추가하고 수정할수 있게 되어있습니다. 사진을 추가할때는 사진을 읽고, 그림을 보여준뒤 이를 그대로 보내주면 되기 때문에 어렵지 않았으나, 수정할때에는 기존에 있던 사진도 삭제할수 있어야 하고, 새롭게 사진을 추가할수도 있어야 하기에, 기존에 사진을 추가하는 로직을 그대로두고, 새롭게 기존에 있던 사진을 삭제할수 있는 기능을 추가함으로써 해결하였습니다.

## 10. 테스트

리덕스와 컴포넌트에 대하여 단위테스트를 진행하였습니다. 간단한 로직 몇가지를 제외한다면 대부분 진행하였습니다. 기본적으로 프레젠테이션의 경우 스냅샷을 찍고 원하는 태그가 잘 렌더링 되는지를 확인하고, 이벤트가 작동하는지를 체크하였고, 비즈니스 로직의 경우, 함수 혹은 useEffect 내의 로직이 잘 작동하는지를 점검하였습니다. jest와 test-libaray를 이용하였으나, 리덕스 의 경우 redux-mock-store 나 redux-saga-test-plan 과 같이 테스트를 편리하게 도와주는 도구를 이용하였습니다.

테스트 하면서 가장 어려웠던 부분은 객체를 useref 훅이었습니다. 대부분의 객체는 spy를 이용하면 mocking이 가능했는데, 해당 훅은 일반적이지 않았고, 특히 여러개 존재할경우 mockReturnValueOnce를 사용해도 먹히지 않아서, 이를 두번씩 사용해야 해당 값이 반영되는등의 이슈가 있었습니다.

## 11. 폴더구조

컴포넌트 폴더의 경우, 도메인을 기준으로 분리하였습니다. 또한 같은 도메인 내에서는 너무 복잡해지지 않으면서, 한개의 컴포넌트로 적절히 이용가능하도록 분리하였습니다. 중복이 존재하여 분리하는 경우에는 해당 도메인 내에서만 사용하면 해당도메인 내에 commons를 추가하였고, 그렇지 않고 전역에서 사용되는 경우라면 최상단에 있는 common 에 추가하였습니다. 커스텀 hook의 경우도 위와 동일한 기준을 적용시켜 사용하였습니다.

리덕스에서의 경우, 리듀서를 분리할때, 한가지 카테고리를 가지게 하려고 노력하였습니다. 가령 검색할때 필요한 모달창 접는 상태, 맵클릭 상태 등을 모두 한 리듀서에 모을수도 있었지만, 이를 분리하여 둠으로써 조금더 직관적으로 내용을 파악할수 있도록 하였습니다.
